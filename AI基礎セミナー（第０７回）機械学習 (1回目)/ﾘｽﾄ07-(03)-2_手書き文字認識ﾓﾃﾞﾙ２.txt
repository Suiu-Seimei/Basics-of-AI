#********************************************************************/
# ﾘｽﾄ07-(03)-2_手書き文字認識ﾓﾃﾞﾙ２
#--------------------------------------------------------------------
# 「手書き文字認識ﾓﾃﾞﾙ２」
#  ２層の畳み込みﾆｭｰﾗﾙﾈｯﾄﾜｰｸ（CNN）
#********************************************************************/
# 参照ﾗｲﾌﾞﾗﾘ
import numpy as np
from keras.models import Sequential
from keras.layers import Dense, Conv2D, MaxPooling2D
from keras.layers import Activation, Dropout, Flatten, Dense
from keras.optimizers import Adam
import time

#********************************************************************/
# reshape_for_model2                                                */
# ﾛｰﾄﾞした MNIST ﾃﾞｰﾀを「手書き文字認識ﾓﾃﾞﾙ２」                     */
# 用に変形したものを返す                                            */
#-------------------------------------------------------------------*/
# 引数：                                                            */
#   in_image ：入力画像：uint8（入力画像枚数,28,28)                 */
#   in_label ：入力画像が表す数値（0〜9）：uint8（入力画像枚数)     */
#-------------------------------------------------------------------*/
# 戻り値：                                                          */
#  (1) in_image を                                                  */
#    「３次元(入力画像枚数,28,28)、uint8(0〜255)」から              */
#    「４次元(入力画像枚数,28,28,1)、float32(0.0〜1.0)」            */
#     へ正規化したもの。                                            */
#     ４次元目は「ﾁｬﾈﾙ数」で本件はﾓﾉｸﾛ画像なので1(ｶﾗｰ画像なら3)     */
#  (2) in_label を                                                  */
#    「１次元(入力画像枚数)、uint8(0〜8：入力画像が表す数値)）から  */
#    「1-of-k 符号化」で 10ｸﾗｽへ分類し「２次元(入力画像枚数,10)」   */
#     各ｸﾗｽへの所属確率を float32(0.0〜1.0)で表現したもの           */
#     へ変換したもの                                                */
#********************************************************************/
def reshape_for_model2(in_image, in_label):
    out_image = in_image.reshape(in_image.shape[0], \
                                 in_image.shape[1], in_image.shape[2], 1)
    out_image = out_image.astype('float32')
    out_image = out_image / IMG_GRAY_LEVEL
    out_label = np_utils.to_categorical(in_label, IMG_CLASS_NO)
    return  out_image, out_label


#********************************************************************/
# make_and_evaluate_model2                                          */
# 「手書き文字認識ﾓﾃﾞﾙ２」を作成してそれを評価する                  */
#   隠れ層の活性化関数は引数で指定可能                              */
#-------------------------------------------------------------------*/
# 「手書き文字認識ﾓﾃﾞﾙ２」                                          */
#  ２層の畳み込みﾆｭｰﾗﾙﾈｯﾄﾜｰｸ（CNN）                                 */
#                                                                   */
# (1) 入力層から出力層に向けて一方通行で流れる(Sequential)。        */
# (2) 入力層の入力ﾃﾞｰﾀは、                                          */
# 　　(Y方向ｻｲｽﾞ, X方向ｻｲｽﾞ, 入力ﾁｬﾈﾙ数) = (28,28,1) とする。       */
# 　　「入力ﾁｬﾈﾙ数」はﾓﾉｸﾛ画像なので1(ｶﾗｰ画像なら3) 。              */
# 　　　値は、[0〜255]の 256 諧調のところを、                       */
# 　　　255 で割って[0〜1] に正規化したものを用いる。               */
#                                                                   */
# (3) 入力と出力の間に、１つの中間層（隠れ層）を置く。              */
# 　　中間層を１段のみとし、中間層を構成する畳み込み層は１段のみ、  */
# 　　正規化層とﾌﾟｰﾘﾝｸﾞ層は無し。                                   */
# 　　畳み込み層のﾌｨﾙﾀ数は 8 で、ﾌｨﾙﾀｻｲｽﾞは 3×3 とする。           */
# 　　Padding="same" でﾌｨﾙﾀをかけることにより、                     */
# 　　結果の特徴ﾏｯﾌﾟ 28×28 を 8枚で出力する。                      */
# 　　中間層の出力を「Flatten」層を通すことで、                     */
# 　　「28×28×8枚×入力ﾁｬﾈﾙ数」という                             */
# 　　４次元のﾃﾞｰﾀを一次元化して、出力層との間で全結合させる。      */
#                                                                   */
# (4) 出力層のﾉｰﾄﾞ数は、10 (入力画像の文字の種類(0〜9)の数)である   */
# 　　ﾃﾞｰﾀ型は「float32 (入力画像枚数,10)」で、                     */
# 　　入力画像の各ｸﾗｽへの所属確率[0〜1]を表す。                     */
#                                                                   */
# (5) 中間層の活性化関数は「relu」                                  */
# (6) 出力層の活性化関数は「softmax」                               */
# (7) 損失関数(誤差を計算する関数)は「categorical_crossentropy」    */
# (8) 学習方法(ﾓﾃﾞﾙの最適化方法)は「Adam」                          */
# (9) 学習時には「ｴﾎﾟｯｸ数」として10、                               */
# 　 「ﾊﾞｯﾁｻｲｽﾞ」として「1000」で学習を行う。                       */
#-------------------------------------------------------------------*/
# 引数：                                                            */
#   title    : 表示用ﾀｲﾄﾙ                                           */
#   actvFunc : 隠れ層の活性化関数                                   */
#-------------------------------------------------------------------*/
# 戻り値：                                                          */
#   (1) 作成したﾓﾃﾞﾙ                                                */
#********************************************************************/
def make_and_evaluate_model2(title, actvFunc):

    print("*********************************************************")
    print(title)
    print("*********************************************************")

    #=================================================================
    # ﾛｰﾄﾞしたMNIST ﾃﾞｰﾀを「手書き文字認識ﾓﾃﾞﾙ２」用に変形する。
    #=================================================================
    inTrain2, outTrain2 = reshape_for_model2(x_train, y_train)
    inTest2, outTest2 = reshape_for_model2(x_test, y_test)

    titlestr = ["modified ...", "inTrain2", "outTrain2", "inTest2", "outTest2"]
    print_MNIST_attr(titlestr, inTrain2, outTrain2, inTest2, outTest2)

    #=================================================================
    # 「手書き文字認識ﾓﾃﾞﾙ２」を作成
    #=================================================================
    np.random.seed(1)
    predmodel = Sequential()
    predmodel.add(Conv2D(8, (3, 3), padding='same',
        input_shape=(IMG_SIZE_Y, IMG_SIZE_X, 1), activation=actvFunc))
    predmodel.add(Flatten())
    predmodel.add(Dense(IMG_CLASS_NO, activation='softmax'))
    predmodel.compile(loss='categorical_crossentropy',
        optimizer=Adam(), metrics=['accuracy'])
    predmodel.summary()

    #=================================================================
    # 「手書き文字認識ﾓﾃﾞﾙ２」を学習し、
    # 学習状況を、ｴﾎﾟｯｸ回数の時系列でｸﾞﾗﾌ表示する
    #=================================================================
    epochNo = 10
    batchSize = 1000

    startTime = time.time()
    history = predmodel.fit(inTrain2, outTrain2, 
        epochs=epochNo, batch_size=batchSize,
        verbose=0, validation_data=(inTest2, outTest2))
    score = predmodel.evaluate(inTest2, outTest2, verbose=0)
    endTime = time.time()

    print('Test loss:', score[0])
    print('Test accuracy:', score[1])
    print("Computation time:{0:.3f} sec".format(time.time() - startTime))

    plot_learning_curve( history, epochNo )

    #=================================================================
    # 「手書き文字認識ﾓﾃﾞﾙ２」で、
    # MINTSTの検証用ﾃﾞｰﾀの最初の50枚で分類結果を表示する。
    #=================================================================
    pred_test_and_show_result(predmodel, inTest2, y_test, IMG_SIZE_X, IMG_SIZE_Y, 50)
    
    return predmodel


#********************************************************************/
# 「手書き文字認識ﾓﾃﾞﾙ２」で
#  活性化関数を「relu」でﾓﾃﾞﾙを作成して評価する
#********************************************************************/
predmodel2 = make_and_evaluate_model2(
    "「２層の畳み込みﾆｭｰﾗﾙﾈｯﾄﾜｰｸ（CNN）」で活性化関数は「relu」",'relu')
       
#********************************************************************/
# 「手書き文字認識ﾓﾃﾞﾙ２」で、
# 自作の画像の分類結果を表示する。
#********************************************************************/
pred_myData_and_show_result("手書き文字認識ﾓﾃﾞﾙ２（CNN,relu）", predmodel2, reshape_for_model2)

