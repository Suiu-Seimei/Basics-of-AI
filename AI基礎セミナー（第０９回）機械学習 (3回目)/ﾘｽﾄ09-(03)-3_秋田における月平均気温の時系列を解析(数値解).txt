#************************************************************************/
# ﾘｽﾄ09-(03)-3_秋田における月平均気温の時系列を解析(数値解)
#------------------------------------------------------------------------
# D次元線形回帰ﾓﾃﾞﾙを勾配法を用いて解析 (D=1)
#------------------------------------------------------------------------
#（気象庁提供）
#「秋田」における「観測開始からの毎月の値」のうち
#「日平均気温の月平均値（℃）」
#　・・・「1883年〜2020年」の期間で、2月と8月に着目
#
# http://www.data.jma.go.jp/obd/stats/etrn/view/monthly_s3.php?
#     prec_no=32&block_no=47582&year=2020&month=&day=&view=a1
#************************************************************************/
import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline

#************************************************************************/
# データ (「秋田」における2月と8月の平均気温の年系列)
#*****************************l*******************************************/
# データ (年)
yyyy= [1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,
       1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,
       1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,
       1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,
       1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,
       1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,
       2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020]
# データ (2月の平均気温)
tFeb = [-2.6,-0.9,-1.9,-2.1,-0.4,-3.7,-1.5,0.6,-1.7,-1.3,-3.6,-0.9,-1.5,-0.9,-1.3,0.3,-0.9,-2.1,
        -0.9,-1.6,0.5,-0.8,-2.4,-2.2,-2.2,-2.0,-2.0,-2.2,-0.5,1.0,-1.7,-0.6,-1.0,-0.5,-1.2,-1.9,-1.3,-1.9,
        -0.9,0.9,-1.9,-1.7,-2.4,-0.9,-2.9,-1.5,-2.3,0.7,-3.0,-0.5,-2.8,-1.1,0.2,-1.5,0.2,-1.2,-1.8,-1.5,
        -0.7,-2.6,-0.8,-1.9,-3.5,-0.5,-2.0,-0.9,2.3,0.0,-0.2,-2.8,-1.5,0.7,0.2,-1.2,-1.1,1.2,2.1,1.1,
        -0.7,-0.1,0.0,-1.0,-1.0,0.1,-0.3,-1.2,-0.8,-0.1,-0.1,0.3,1.6,-0.5,-0.5,0.2,-0.9,-2.5,2.0,-1.4,
         0.4,-1.0,-0.5,-2.3,0.5,-1.6,0.2,-2.0,1.9,3.0,0.5,0.5,2.1,1.3,1.1,0.3,1.3,1.3,0.5,0.2,
         -0.8,1.9,0.7,2.0,-0.5,0.9,2.7,0.0,1.4,0.4,1.1,-1.0,-0.5,-0.1,2.3,0.9,1.3,-0.9,1.5,2.5 ]
# データ (8月の平均気温)
tAug = [23.6,22.5,24.1,25.1,24.4,23.4,23.4,25.4,21.8,23.6,24.0,23.8,24.5,24.0,23.3,24.6,23.5,24.9,
        23.3,21.3,22.1,24.4,20.5,22.9,25.6,24.8,23.9,22.7,23.6,24.4,21.3,24.1,24.1,25.3,23.4,24.1,22.9,25.0,
        23.9,25.1,24.2,24.9,25.0,23.0,24.2,24.4,24.7,25.4,23.9,23.7,25.4,21.8,22.7,22.9,25.2,26.4,24.7,23.1,
        23.0,23.5,26.1,24.8,25.0,25.5,23.8,24.9,25.0,25.9,25.1,23.5,22.8,24.0,25.0,22.3,24.4,23.1,23.6,24.7,
        24.7,24.5,24.1,25.5,24.5,24.9,24.5,23.4,23.4,24.5,23.7,23.1,25.5,24.1,25.1,21.4,22.9,25.3,24.0,22.3,
        23.1,24.6,25.3,25.3,27.3,24.5,23.8,26.1,25.2,25.5,23.4,24.4,21.9,26.9,24.4,24.1,24.2,23.5,27.3,26.8,
        24.3,24.3,23.1,24.3,25.9,26.5,25.1,23.9,23.8,27.0,25.5,26.8,25.4,24.6,24.8,26.4,24.9,25.0,26.5,26.2 ]

#************************************************************************/
# fStandardize                                                          */
# 指定したデータを標準化し、その結果と平均・標準偏差を返す。            */
#-----------------------------------------------------------------------*/
# 引数：                                                                */
#   x ：対象のデータリスト（ﾃﾞｰﾀの組分）                                */
#-----------------------------------------------------------------------*/
# 戻り値：                                                              */
# (第１返値) z    ：指定したデータの標準化結果                          */
# (第２返値) xAve ：指定したデータの平均                                */
# (第３返値) xStd ：指定したデータの・標準偏差                          */
#************************************************************************/
def fStandardize( x ):
    xAve = np.average(x)
    xStd = np.std(x)

    if xStd == 0.0 :
        return x, xAve, xStd
    else:
        z = np.zeros([len(x)])
        for n in range(0, len(x)):
            z[n] = (x[n] - xAve)/ xStd
        return z, xAve, xStd

#************************************************************************/
# fGetEtha                                                              */
# 学習係数η を取得する関数                                             */
#-----------------------------------------------------------------------*/
# 引数： 無し                                                           */
#-----------------------------------------------------------------------*/
# 戻り値：学習係数η                                                    */
#************************************************************************/
def fGetEtha():
    return 0.001

#************************************************************************/
# fGetDelJ                                                              */
# 平均二乗誤差Ｊの勾配∂J/∂wd(d=0〜D:偏回帰係数の組)を計算する関数     */
#-----------------------------------------------------------------------*/
# 引数：                                                                */
#   dimNo  : 線形回帰ﾓﾃﾞﾙの次元数D (≧1)                                */
#   xList  : 説明変数 [n,d]  (n=1〜N：観測値の組、d=0〜D:説明変数の組)  */
#   tList  : 目的変数 [n]    (n=1〜N：観測値の組)                       */
#   wList  : 偏回帰係数 [d]  (d=0〜D:偏回帰係数の組)                    */
#-----------------------------------------------------------------------*/
# 戻り値：                                                              */
#   第1戻り値：delJ[d]：平均二乗誤差Ｊの勾配∂J/∂w[d] (d=0〜D)         */
#   第2戻り値：J      ：平均二乗誤差Ｊ(RMSE)                            */
#************************************************************************/
def fGetDelJ(dimNo, xList, tList, wList):
    delJ = np.zeros(dimNo+1)
    dtN = len(tList)
    se = 0.0

    for n in range(0, dtN):
        # ﾓﾃﾞﾙの計算値
        yn = np.dot(wList, xList[n])
        se = se + (yn - tList[n])**2

        #∂J/∂wd の計算
        for d in range(0, dimNo+1):
            delJ[d] = delJ[d] + (yn - tList[n]) * xList[n,d]
        delJ[d] = 2* delJ[d] / dtN

    rmse = np.sqrt(se/dtN)
    return delJ, rmse
    
#************************************************************************/
# fFitting                                                              */
# 勾配法による線形回帰ﾓﾃﾞﾙの作成                                        */
#-----------------------------------------------------------------------*/
# 引数：                                                                */
#   dimNo  : 線形回帰ﾓﾃﾞﾙの次元数D (≧1)                                */
#   xList  : 説明変数 [n,d]  (n=1〜N：観測値の組、d=0〜D:説明変数の組)  */
#   tList  : 目的変数 [n]    (n=1〜N：観測値の組)                       */
#-----------------------------------------------------------------------*/
# 戻り値：                                                              */
#   第1戻り値：delJ[d]：平均二乗誤差Ｊの勾配 (d=0〜D:偏回帰係数の組)    */
#   第2戻り値：fitW[d]：偏回帰係数 (d=0〜D:偏回帰係数の組)              */
# 　第3戻り値：jHist[t]：平均二乗誤差Ｊの (t:計算ｽﾃｯﾌﾟ)                 */
# 　第4戻り値：tLast：   最終的な計算ｽﾃｯﾌﾟ数                            */
#************************************************************************/
def fFitting(dimNo, xList, tList):
    if dimNo <= 0 :
        return None, None

    # 計算用の定数
    GRAD_THRESHOLD= 0.001 # 勾配の変化率のしきい値
    GRAD_REPEAT = 30      # 勾配の変化率がしきい値未満となる回数の最大値
    REPEAT_MAX = 300      # 最大繰り返し回数

    # 学習係数η の初期値
    etha = fGetEtha()

    # 偏回帰係数の初期化
    wHist = np.zeros([REPEAT_MAX, dimNo+1])
    wHist[0,:] = np.full(dimNo+1, 1/(dimNo+1))

    # 勾配降下法による逐次近似
    jHist = np.zeros([REPEAT_MAX])
    tLast = 0
    jLast = 0
    gradRptNo = 0
    diffJ = 0

    for t in range(0, REPEAT_MAX-1):
        tLast = t
        delJ, jHist[t] = fGetDelJ(dimNo, xList, tList, wHist[t,:])
        
        # 収束判定用の勾配の変化率が、
        # 勾配の大きさの1000分の１以下の状態が、30回続いたら
        # 逐次近似処理を打ち切る
        diffJ = np.abs(jHist[t] - jLast)
        if (diffJ / jHist[t]) < GRAD_THRESHOLD :
            gradRptNo = gradRptNo + 1;
        else:
            gradRptNo = 0
        if gradRptNo > GRAD_REPEAT :
            break            

        # 偏回帰係数の更新
        for d in range(0, dimNo+1):
            wHist[t+1,d] = wHist[t,d] - etha * delJ[d]

        # 直前のJ
        jLast = jHist[t]

    # 偏回帰係数の最終値
    fitW = wHist[tLast,:]
    
    print("(etha)={0}".format(etha))
    print("(tLast)={0}".format(tLast))
    print("(delJ)={0}".format(delJ))
    print("(fitW)={0}".format(fitW))

    return delJ, fitW, jHist, tLast
    
#************************************************************************/
# fCalcAndShow                                                          */
# 線形回帰ﾓﾃﾞﾙの作成と、回帰曲線と学習曲線の表示                        */
#-----------------------------------------------------------------------*/
# 引数：                                                                */
#   title  : ｸﾞﾗﾌ表示のﾀｲﾄﾙ                                             */
#   yyyy   : 説明変数 [n]  (n=1〜N：観測値の組、1次元)                  */
#   t      : 目的変数 [n]  (n=1〜N：観測値の組、1次元)                  */
#-----------------------------------------------------------------------*/
# 戻り値：  なし                                                        */
#************************************************************************/
def fCalcAndShow(title, yyyy, t):

    # 入力ﾃﾞｰﾀの次元数
    dimNo = 1
    print("次元数   D={0}".format(dimNo))
    
    # データ数
    N = len(t)
    print("データ数 N={0}".format(N))

    # 説明変数（計算の収束と桁あふれ防止用にﾃﾞｰﾀの標準化を施す）
    zList, xAve, xStd = fStandardize(yyyy)
    xList = np.zeros([N, dimNo+1])
    for n in range(0, N):
        xList[n,0] = 1
        for d in range(1, dimNo+1):
            xList[n,d] = zList[n]

    # 目的変数の標準化（計算の収束と桁あふれ防止用）
    tList, tAve, tStd = fStandardize(t)

    # 偏回帰係数を算出し、回帰直線の座標を計算
    delJ, fitW, jHist, tLast = fFitting(dimNo, xList, tList)
    y = np.zeros(N)
    for n in range(0, N):
        y[n] = (np.dot(fitW, xList[n]) * tStd) + tAve

    # データとモデルによる計算結果を表示
    plt.figure(figsize=(15, 3))
    plt.title(title)
    plt.plot(yyyy, t, marker='o', linestyle='None',
             markeredgecolor='black', color='cornflowerblue')
    plt.plot(yyyy, y, color='red', linewidth=3, linestyle='--', )
    plt.xlim(np.min(yyyy)-1, np.max(yyyy)+1)
    plt.ylim(np.min(t)+1, np.max(t)-1)
    plt.xlabel("Year")
    plt.ylabel("Temp.(C)")
    plt.grid(True)
    
    # 学習の履歴を表示
    jstep = np.zeros(len(jHist))
    for t in range(0, len(jHist)):
        jstep[t] = t

    plt.figure(figsize=(15, 3))
    plt.title("Learning Curve")
    plt.plot(jstep, jHist, marker='o', linestyle='None',
             markeredgecolor='black', color='cornflowerblue')
    plt.xlim(0, tLast)
    plt.ylim(np.min(jHist[:tLast])-0.1, np.max(jHist[:tLast])+0.1)
    plt.xlabel("step")
    plt.ylabel("RMSE")
    plt.grid(True)
    plt.show()    

#************************************************************************/
# メイン処理                                                            */
#************************************************************************/

# (2月)
fCalcAndShow("Time series of February Temp(C) at Akita", yyyy, tFeb)

# (8月)
fCalcAndShow("Time series of August Temp(C) at Akita", yyyy, tAug)
